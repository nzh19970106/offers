1. 创建唯一性索引，可以保证数据库表中每一行数据的唯一性
2. - 原子性(Atomicity)
   一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
   事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。
   - 一致性(Consistency)
   事务的一致性指在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。
   - 隔离性(Isolation)
   指在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。
   由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。
   - 持久性(Durability)
   指只要事务成功结束，它对数据库所做的更新必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。  
   MySQL的InnoDB存储引擎使用Redo log保证了事务的持久性，当事务提交时，必须先将事务的所有日志写入日志文件进行持久化。
3. 四个隔离级别
   脏读(Dirty Reads) 读未提交(Read uncommitted)
   脏数据是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据处于待定状态，这时，第二个事务来读取这条没有提交的数据，并据此做进一步处理，就会产生未提交的数据依赖关系。
   不可重复读(Non-Repeatable Reads) 读提交(Read committed)
   一个事务先后读取同一条记录，但两次读取的数据不同
   幻读(Phantom reads) 重复读(Repeatable read)
   一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据
   串行读(Serializable) 序列化(Serializable)
   完全串行化读，读取使用表级共享锁，读写都会阻塞，隔离级别最高
4. 普通索引：仅加速查询
   唯一索引：加速查询+列值唯一(可以有null)
   主键索引：加速查询+列值唯一(不可以有null)+表中只有一个
   组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
   全文索引：对文本的内容进行分词，进行搜索
   索引合并：使用多个单列索引组合搜索
   覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建索引覆盖
   聚簇索引：表数据是和主键一起存储的，主键索引的叶节点存储行数据，二级索引的叶节点存储行的主键值。使用B+树作为索引的存储结构，非叶子节点都是索引的关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录
5. 聚集索引与非聚集索引的区别：
   - 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个
   - 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续
   - 聚集索引：物理存储按照索引排序，是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序
   - 非聚集索引：物理存储不按照索引排序，非聚集索引则就是普通索引，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序
   - 索引是通过二叉树的数据结构来描述的，聚集索引的叶节点是数据节点，非聚集索引的叶节点仍是索引节点，只不过有一个指针指向对应的数据块。
6. 1NF：无重复的列，字段不可分；2NF：非主属性非部分依赖于关键字，即有主键，非主键
   字段依赖主键；3NF：非主键字段不能相互依赖。
7. MySQL优化：
   - 为搜索字段创建索引
   - 避免使用Select*，列出需要查询的字段
   - 垂直分割分表
   - 选择正确的存储引擎
8. MySQL怎样执行一条SQL语句
   - 客户端请求
   - 连接器（验证用户身份，给予权限）**管理连接、权限验证**
   - 查询缓存（存在缓存则直接返回，不存在则执行后续操作）**命中缓存则直接返回结果**
   - 分析器（对SQL进行词法分析和语法分析操作）**对SQL进行词法分析、语法分析**
   - 优化器（主要对执行的sql优化选择最优的执行方案方法）**执行计划生成、选择索引**
   - 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）**操作引擎、返回结果**
   - 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）**存储数据、提供读写接口**
9. MySQL分为服务层和存储引擎层两部分
    - 服务层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程。触发器、视图等。
    - 存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。
10. InnoDB
    - MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
    - 实现了四个标准的隔离级别，默认级别是可重复读。在可重复读隔离级别下，通过多版本并发控制(MVCC)+间隙锁(Next-key Locking)防止幻读
    - 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动
    创建的自适应哈希索引、能够加速插入操作的插入缓冲区等
    - 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对
    所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。
    MyISAM
    - 设计简单，数据以紧密格式存储。对于只读数据，或者表比较下、可以容忍修复操作，则依然可以使用它
    - 提供了大量特性，包括压缩表、空间数据索引等
    - 不支持事务
    - 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但在表有读取操作的同时，也可以往表中插入新的记录，即并发插入。
11. 表锁：不会出现死锁，发生锁冲突几率高，并发低
    行锁：会出现死锁，发生锁冲突几率低，并发高。行锁是加在索引响应的行上，两个事务不能锁在同一个索引。
    悲观锁：假设会发生冲突，屏蔽一切可能违反数据完整性的操作
    乐观锁：假设不会发生冲突，只在提交操作时检查是否违反完整性
12. 垂直拆分：表与表之间的io竞争
    水平拆分：单表中数据量增长出现的压力
    用户表、订单表、产品表
13. B+树按照节点分段加载，由此减少内存消耗
    唯一查找，hash更快，但是数据库中经常查询多条数据，由于B+树数据的有序性，与叶子节点又有链表相连，查询效率更高
    B+树的非叶子节点不保存数据，只保存子树的临界值，因此同样大小的节点，B+树相对于B树能够有更多的分支，是的这棵树更加矮胖，查询时做的IO操作次数也更少。
14. 数据库高并发的解决方案
    - 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担
    - 增加数据库索引，进而提高查询速度
    - 主从读写分离，让主服务器负责写，从服务器负责读
    - 将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度
    - 使用分布式架构，分散计算压力。