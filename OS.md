1. 进程通信的基本方式
   - 管道:半双工的通信，数据只能单向流动；只能在具有亲缘关系的进程间使用
     流管道，可以双向传输；命名管道，允许无亲缘关系进程间通信
   - 信号，用于通知接收进程某个事件的发生
   - 信号量(Semephore)，用于进程同步
   - 消息队列,由消息链表，存放在内核中并由消息队列标识符标识
   - 共享内存
   - 套接字，用于不同机器间进程通信
2. 线程通信:临界区、互斥量、信号量、信号
   **协程是用户态的轻量级线程，线程内部调度的基本单位，同一时间只能执行一个协程，而其他**
   **协程处于休眠状态，适合对任务进行分时处理(共享内存、消息队列)**
3. 进程的缺点：
   - 进程在同一时间只能干一件事
   - 进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行
   线程的优势：
   - 占用资源少
   - 同一进程下的线程切换效率更高
   进程调度算法：先来先服务、时间片轮转法、最短进程优先、
                最短剩余时间优先、最高响应比优先、多级反馈队列
   一个进程可以打开多个文件描述符，而每个文件描述符对应一个端口号，所以一个进程可以绑定多个端口号。
   如果进程先绑定一个端口号，然后再fork一个子进程，这样实现多个进程绑定一个端口号，但是两个不同进程不能绑定一个端口号。  
   内核为每一个进程维持一个上下文，上下文是内核重新启动一个被抢占的进程所需的状态。
   包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表  
4. 系统调用将Linux整个体系分为用户态和内核态(内核空间和用户空间)
   内核态，本质上是我们所说的内核，是一种特殊的软件程序，控制计算的硬件资源，
   例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行
   用户态，提供应用程序运行的空间，为了使用应用程序访问到内核管理的资源如CPU，内存，I/O，
   内核必须提供一组通用的访问接口，这些接口叫系统调用。
   用户态切换到内核态的切换方式：
   - 系统调用，系统调用本身是中断，但是软中断，跟硬中断不同
   - 异常：如果当前进程运行在用户态，如果此时发生了异常事件，就会触发切换，如缺页
   - 外设中断：当外设完成用户的请求时，会向CPU发出中断信号
5. 操作系统的缺页中断
   保护CPU现场——分析中断原因——转入缺页中断处理程序——恢复CPU现场，继续执行
   缺页中断是由于要访问的页面不存在于内存时，由硬件所产生的的一种特殊的中断，
   与一般中断的区别是：
   - 在指令执行期间产生和处理缺页中断信号
   - 一条指令在执行期间，可能产生多次缺页中断
   - 缺页中断返回是，执行产生中断的一条指令，而一般中断返回是，执行下一条指令
6. 虚拟内存的基本思想：每个程序拥有自己的地址空间，这个空间被分割成多个块，
   每一块称作一页或页面。每一页有连续的地址范围。这些页被映射到物理空间，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到的一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。
7. 把每个段都看作一个虚拟内存并对它分页，以结合分页的优点(统一的页面大小和在只使用段的一部分时不 用把它全部调入内存)和分段的优点(易于编程、模块化、保护和共享)
 访问内存时，执行如下算法：
 1）根据段号找到描述符
 2）检查该段的页表是否在内存中。如果在，则找到它的位置；如果不在，则产生一个段错误。如果访问违反了段的保护要求就发出一个越界错误(陷阱)
 3）检查所请求虚拟页面的页表项，如果该页面不在内存中则产生一个缺页中断，如果在内存就从页表项中取出这个页面在内存中的起始地址。
 4）把偏移量加到页面的起始地址上，得到要访问的字在内存中的地址。
 5) 最后进行读或写操作。
8. 死锁
   如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。
   原因：系统资源不足、资源分配不当、进程运行推进顺序不合适
   产生条件：
   - 互斥条件：一个资源每次只能被一个进程使用
   - 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不变
   - 不可抢占条件：进程已经获得的资源，在未使用完之前，不能强行剥夺
   - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系
   死锁的解除方法：剥夺资源和撤销进程
   四种处理死锁的策略：
   1）忽略该问题。如果你忽略它，它也会忽略你。
   2）检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。
    死锁恢复：利用抢占恢复、利用回滚恢复、通过杀死进程恢复。
   3）仔细对资源进行分配，动态地避免死锁。
   4）通过破坏引起死锁的四个必要条件之一，防止死锁的产生。
9. 程序加载至启动过程
    Explore.exe是Windows程序管理器或文件资源管理器用于管理Windows的图形壳，
    启动进入电脑桌面后，系统会创建ExPlorer.exe进程，当双击某个图标时，Explorer.exe
    进程的一个线程会侦测到这个操作，它会根据注册表中的信息取得文件名，然后Explorer.exe
    以这个文件名调用CreateProcess函数。注册表中有相关的项保存着双击操作的信息，如EXE文件关联、
    启动exe的Shell是哪个。
    1）CreateProcess是由NtCreateProcess函数实现到的，系统会创建一个进程内核对象。进程内核对象维护一个句柄表
    2）进程内核对象创建后，引用计数置为1，然后系统能为刚创建的进程分配虚拟地址空间。
    3）初始化虚拟地址空间。进程地址空间创建后，Windows装载器(loader)会读取EXE文件(PE文件)的信息，检查有效性后，Loader将PE文件内容映射到进程的地址空间，读取PE文件的导入地址表(Import Table),加载DLL模块文件到进程的地址空间(DLL只需加载一次就可映射到所有进程的地址空间)，进程初始化部分完成。
    4）创建进程的主线程。进程初始化后，开始创建进程的主线程。线程是CreateThread函数创建，创建线程内核对象，初始化线程堆栈。
    5）C/C++运行期库初始化。当进程的主线程初始化完成后，并线程得到CPU时间片，CPU把CS:IP指向程序入口，完成C++的初始化后，用户程序代码开始执行。
10. - 用户输入命令，在shell下启动一个前台进程
    - 用户按下Ctrl-C，这个键盘输入产生一个硬件中断
    - 如果CPU当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行，
        CPU从用户态切换到内核态处理硬件中断
    - 终端驱动程序将Ctrl-C解释成一个SIGINT信号，记在该进程的PCB中
    - 当某个时刻要从内核返回该进程的用户空间继续执行前，首先处理PCB中记录的信号，
      发现有一个SIGINT信号待处理，而这个信号的默认处理动作是终止进程，因此直接终止进程
      而不再返回用户空间执行代码。
11. 静态编译与动态编译
    - 静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取
      出来，链接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；
    - 动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应的
      动态链接库的命令。缩小可执行文件的体积、加快编译速度、节省资源。
12. 系统调用：用户程序和硬件设备之间的桥梁。用户程序在需要的时候，通过系统调用
             来使用硬件设备。
             1）用户程序通过系统调用来使用硬件，不用关心具体硬件设备，简化开发。
             2）系统调用使用户程序有更好的可移植性，只要操作系统提供相同的调用接口
             3）系统调用由内核实现，使得内核能更好的管理用户程序，系统更稳定
             4）系统调用有效的分离了用户程序和内核的开发
      Linux系统调用的实现原理：
      - 通知内核调用哪个系统调用
      - 用户程序把系统调用参数传递给内核
      - 用户程序获取内核返回的系统调用返回值
13. 回调函数
    - 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数
    - 回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用
    - 回调函数是一个通过函数指针调用的函数
    - 把调用者与被调用者分开，调用者不需要关心被调用者是谁。
14. 一致性哈希：在移除或者增加一个节点时，能够尽可能小的改变已存在key的映射关系
    一致性哈希将整个哈希值空间组织成一个虚拟的圆环，假设哈希函数的值空间为0~2^31
    一致性hash的基本思想是使用相同的hash算法将数据和节点映射到图中的环形哈希空间
    然后沿着顺时针方向寻找，找到一个节点将数据存在这个节点上。
    移除节点和添加节点仅影响其逆时针方向到下一个节点之间的数据
   虚拟节点是实际物理节点的复制品，一个实际节点可以对应多个虚拟节点，可以使缓存数据
   分布平衡，缓解hash环倾斜问题。
15. 非抢占式算法：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权更高的进程。  
    抢占式算法：系统先把处理机分配给优先权最高的进程，在其执行期间出现了优先权更高的进程，进程调度程序会立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。